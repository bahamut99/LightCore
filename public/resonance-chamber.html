<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Resonance Core [LightCore]</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Roboto+Mono:wght@300;400&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Roboto Mono', monospace; background-color: #0a0a1a; color: #00f0ff; overflow: hidden; }
        .font-orbitron { font-family: 'Orbitron', sans-serif; }
        #diagnostic-panel { backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); background: rgba(10, 25, 47, 0.6); border: 1px solid rgba(0, 240, 255, 0.2); }
        .log-entry { border-bottom: 1px solid rgba(0, 240, 255, 0.1); animation: fadeIn 0.5s ease-in-out; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(-10px); } to { opacity: 1; transform: translateY(0); } }
        .glowing-text { text-shadow: 0 0 5px #00f0ff, 0 0 10px #00f0ff, 0 0 15px #00f0ff; }
        .status-nominal { color: #00ff88; text-shadow: 0 0 5px #00ff88; }
        .status-warning { color: #ffd700; text-shadow: 0 0 5px #ffd700; }
        .status-critical { color: #ff4d4d; text-shadow: 0 0 5px #ff4d4d; }
        .scanline { position: absolute; top: 0; left: 0; width: 100%; height: 3px; background: linear-gradient(90deg, rgba(0,240,255,0), rgba(0,240,255,0.8), rgba(0,240,255,0)); animation: scan 4s linear infinite; pointer-events: none; z-index: 100; }
        @keyframes scan { 0% { transform: translateY(-10px); } 100% { transform: translateY(100vh); } }
        .overflow-y-auto::-webkit-scrollbar { width: 4px; }
        .overflow-y-auto::-webkit-scrollbar-track { background: transparent; }
        .overflow-y-auto::-webkit-scrollbar-thumb { background: rgba(0, 240, 255, 0.3); border-radius: 2px; }
    </style>
</head>
<body class="w-screen h-screen">

    <div id="scanline" class="scanline"></div>
    <div id="container" class="absolute top-0 left-0 w-full h-full"></div>

    <div id="diagnostic-panel" class="absolute top-4 right-4 w-full max-w-md h-[calc(100vh-2rem)] rounded-lg shadow-2xl p-4 flex flex-col text-sm overflow-hidden border border-cyan-400/20">
        <div class="flex-shrink-0 pb-4 border-b border-cyan-400/20">
            <h1 class="font-orbitron text-2xl glowing-text">RESONANCE CORE</h1>
            <p class="text-xs text-cyan-300">LIGHTCORE BDT v.2077.6.zeta</p>
        </div>
        
        <div class="flex-shrink-0 py-4 grid grid-cols-2 gap-4">
            <div>
                <p class="font-bold">SUBJECT ID:</p>
                <p id="subject-id" class="text-cyan-200 truncate">SYNCING...</p>
            </div>
             <div>
                <p class="font-bold">SYSTEM STATE:</p>
                <p id="system-status" class="font-bold status-nominal">CALIBRATING...</p>
            </div>
        </div>

        <div class="flex-grow mt-2 overflow-y-auto pr-2">
            <h2 class="font-orbitron text-lg glowing-text mb-2 sticky top-0 bg-[rgba(10,25,47,0.9)] py-1 z-10">AI MEMORY FEED</h2>
            <div id="log-container" class="space-y-3">
                </div>
        </div>
        
        <div class="flex-shrink-0 pt-4 mt-4 border-t border-cyan-400/20 space-y-2">
             <button id="resync-data" class="w-full bg-cyan-600/50 hover:bg-cyan-500/80 text-white font-bold py-2 px-4 rounded transition-all duration-300 border border-cyan-400">
                RE-SYNC WITH LIGHTCORE BRAIN
            </button>
        </div>
    </div>

    <script type="module">
        // --- CONFIGURATION ---
        const SUPABASE_URL = 'https://izbjadizahqlfrdqofyw.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Iml6YmphZGl6YWhxbGZyZHFvZnl3Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTQyMDE1OTksImV4cCI6MjA2OTc3NzU5OX0.sCoMYav2kGtopZsmijAJojBgoN_ay-ddAVYT3I-l6o0';

        const ANOMALY_MAP = {
            'stress': { name: 'Cortisol Cluster', color: 0xffa500, severity: 'WARNING' },
            'anxious': { name: 'Cortisol Cluster', color: 0xffa500, severity: 'WARNING' },
            'fatigue': { name: 'Lactic Acid Cloud', color: 0xff4500, severity: 'WARNING' },
            'sore': { name: 'Myofibril Tearing', color: 0xff4500, severity: 'WARNING' },
            'poor sleep': { name: 'Melatonin Imbalance', color: 0x8A2BE2, severity: 'CRITICAL' },
            'brain fog': { name: 'Neural Misfiring', color: 0xffffff, severity: 'CRITICAL' },
            'hydrated': { name: 'Optimal Osmosis', color: 0x00ffff, severity: 'INFO' },
            'energized': { name: 'Mitochondrial Efficiency', color: 0x00ff88, severity: 'INFO' },
        };

        let scene, camera, renderer, singularity, stardust, anomalyNodes, constellationGroup;
        const container = document.getElementById('container');
        const logContainer = document.getElementById('log-container');
        const systemStatusEl = document.getElementById('system-status');
        const subjectIdEl = document.getElementById('subject-id');
        const resyncButton = document.getElementById('resync-data');
        let supabaseClient;
        let currentAuthToken = null;

        async function fetchAndInitialize(authToken) {
            addLogEntry('INFO', 'Establishing secure link to LightCore Brain...');
            currentAuthToken = authToken;
            supabaseClient = supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY, {
                global: { headers: { Authorization: `Bearer ${authToken}` } }
            });

            const { data: { user } } = await supabaseClient.auth.getUser();
            if (!user) {
                addLogEntry('CRITICAL', 'Authentication failed. Please log in to the main dashboard and refresh.');
                updateSystemStatus('ERROR', '#ff4d4d');
                return;
            }
            subjectIdEl.textContent = user.id.split('-')[0];

            // **BUG FIX**: Added `tags` to the select query
            const { data: logs, error } = await supabaseClient
                .from('daily_logs')
                .select('created_at, clarity_score, immune_score, physical_readiness_score, tags, ai_notes')
                .order('created_at', { ascending: false })
                .limit(15);
            
            if (error || !logs || logs.length === 0) {
                addLogEntry('WARNING', 'No user data found. Running baseline simulation.');
                updateSystemStatus('NOMINAL', '#00ff88');
                const defaultScores = { clarity: 8, immune: 8, physical: 8 };
                if (scene) {
                   while(scene.children.length > 0){ scene.remove(scene.children[0]); }
                }
                initScene();
                createSingularity(defaultScores);
                createStardustField(defaultScores);
                createAnomalyNodesFromLogs([]);
                animate(defaultScores);
                return;
            }
            
            addLogEntry('INFO', 'Bio-metric data stream acquired. Initializing simulation...');
            const latestScores = {
                clarity: logs[0].clarity_score,
                immune: logs[0].immune_score,
                physical: logs[0].physical_readiness_score
            };
            
            if(scene) {
                while(scene.children.length > 0){ scene.remove(scene.children[0]); }
            }
            initScene();
            
            populateHistoricalLogs(logs);
            createSingularity(latestScores);
            createStardustField(latestScores);
            createAnomalyNodesFromLogs(logs);
            animate(latestScores);
            
            // Set final system status based on fetched scores
            const avgScore = (latestScores.clarity + latestScores.immune + latestScores.physical) / 3;
            if (avgScore < 4) updateSystemStatus('CRITICAL', '#ff4d4d');
            else if (avgScore < 7) updateSystemStatus('WARNING', '#ffd700');
            else updateSystemStatus('NOMINAL', '#00ff88');
        }
        
        function initScene() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 25;
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            if (container.firstChild) {
                container.removeChild(container.firstChild);
            }
            container.appendChild(renderer.domElement);
            
            const ambientLight = new THREE.AmbientLight(0x404040, 2);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
            directionalLight.position.set(10, 10, 10);
            scene.add(directionalLight);
            
            constellationGroup = new THREE.Group();
            scene.add(constellationGroup);
        }

        function createSingularity(scores) {
            const avgScore = (scores.clarity + scores.immune + scores.physical) / 3;
            const coreColor = new THREE.Color().lerpColors(new THREE.Color(0xff4d4d), new THREE.Color(0x00f0ff), avgScore / 10);
            const count = 2000;
            const positions = new Float32Array(count * 3);
            const colors = new Float32Array(count * 3);
            const geometry = new THREE.BufferGeometry();
            const radius = 4;
            for(let i=0; i < count; i++) {
                const r = Math.random() * radius;
                const theta = Math.random() * 2 * Math.PI;
                const phi = Math.acos(2 * Math.random() - 1);
                positions[i*3] = r * Math.sin(phi) * Math.cos(theta);
                positions[i*3+1] = r * Math.sin(phi) * Math.sin(theta);
                positions[i*3+2] = r * Math.cos(phi);
                const variedColor = coreColor.clone().multiplyScalar(0.5 + Math.random() * 0.5);
                variedColor.toArray(colors, i * 3);
            }
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            const material = new THREE.PointsMaterial({
                size: 0.05,
                vertexColors: true,
                blending: THREE.AdditiveBlending,
                transparent: true,
                opacity: 0.8
            });
            singularity = new THREE.Points(geometry, material);
            scene.add(singularity);
        }

        function createStardustField(scores) {
            const avgScore = (scores.clarity + scores.immune + scores.physical) / 3;
            const particleColor = new THREE.Color().lerpColors(new THREE.Color(0xffd700), new THREE.Color(0x00f0ff), avgScore / 7);
            const count = 5000;
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(count * 3);
            const velocities = [];
            
            for (let i = 0; i < count; i++) {
                // **ORBIT TIGHTENING**: Particles start in a tighter band
                const r = 10 + Math.random() * 10;
                const theta = Math.random() * 2 * Math.PI;
                const phi = Math.acos(2 * Math.random() - 1);
                positions[i * 3] = r * Math.sin(phi) * Math.cos(theta);
                positions[i * 3 + 1] = r * Math.sin(phi) * Math.sin(theta);
                positions[i * 3 + 2] = r * Math.cos(phi);
                velocities.push(new THREE.Vector3());
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.velocities = velocities;
            const material = new THREE.PointsMaterial({ size: 0.05, color: particleColor, blending: THREE.AdditiveBlending, transparent: true, opacity: 0.8 });
            stardust = new THREE.Points(geometry, material);
            scene.add(stardust);
        }

        function createAnomalyNodesFromLogs(logs) {
            anomalyNodes = [];
            let addedAnomalies = new Set();
            (logs || []).forEach(log => {
                if (!log.tags) return;
                log.tags.forEach(tag => {
                    const anomalyType = ANOMALY_MAP[tag];
                    if (anomalyType && !addedAnomalies.has(anomalyType.name)) {
                        const anomalyNode = new THREE.Object3D();
                        const radius = 8 + Math.random() * 5;
                        const theta = Math.random() * 2 * Math.PI;
                        const phi = Math.acos(2 * Math.random() - 1);
                        anomalyNode.position.set(radius * Math.sin(phi) * Math.cos(theta), radius * Math.sin(phi) * Math.sin(theta), radius * Math.cos(phi));
                        anomalyNode.userData = { type: anomalyType.name, severity: anomalyType.severity, color: anomalyType.color };
                        anomalyNodes.push(anomalyNode);
                        addedAnomalies.add(anomalyType.name);
                    }
                });
            });
        }
        
        function animate(scores) {
            if (!scores || !renderer) return;
            requestAnimationFrame(() => animate(scores));
            const time = Date.now() * 0.0005;
            
            if (singularity) {
                singularity.rotation.y = time * 0.1;
                singularity.rotation.x = time * 0.05;
            }

            if (stardust) {
                updateStardustField();
            }

            renderer.render(scene, camera);
        }

        function updateStardustField() {
            const positions = stardust.geometry.attributes.position;
            const velocities = stardust.geometry.velocities;
            const center = new THREE.Vector3(0, 0, 0);

            constellationGroup.children.forEach(child => {
                child.material.opacity -= 0.005; 
                if(child.material.opacity <= 0) constellationGroup.remove(child);
            });

            for (let i = 0; i < positions.count; i++) {
                const pos = new THREE.Vector3(positions.getX(i), positions.getY(i), positions.getZ(i));
                const vel = velocities[i];
                const distance = Math.max(pos.length(), 1); 
                
                // **ORBIT TIGHTENING**: Stronger gravity when further away
                const gravityStrength = 1 / distance * (distance > 15 ? 0.001 : 0.0005);
                const gravity = center.clone().sub(pos).normalize().multiplyScalar(gravityStrength);
                vel.add(gravity);
                
                const orbitalVel = new THREE.Vector3(-pos.z, 0, pos.x).normalize().multiplyScalar(0.005);
                vel.add(orbitalVel);
                vel.multiplyScalar(0.99); 
                pos.add(vel);

                positions.setXYZ(i, pos.x, pos.y, pos.z);
            }

            if (Math.random() > 0.90) { 
                anomalyNodes.forEach(node => {
                    const nearbyParticles = [];
                    const detectionRadius = 4.0;
                    for (let i = 0; i < positions.count; i += 10) { 
                        const pos = new THREE.Vector3(positions.getX(i), positions.getY(i), positions.getZ(i));
                        if (pos.distanceTo(node.position) < detectionRadius) {
                            nearbyParticles.push(pos);
                        }
                        if (nearbyParticles.length > 5) break;
                    }

                    if (nearbyParticles.length > 2) {
                        const points = [];
                        for(let j = 0; j < nearbyParticles.length; j++){
                            for(let k = j + 1; k < nearbyParticles.length; k++){
                                points.push(nearbyParticles[j]);
                                points.push(nearbyParticles[k]);
                            }
                        }
                        const lineGeometry = new THREE.BufferGeometry().setFromPoints(points);
                        const lineMaterial = new THREE.LineBasicMaterial({ 
                            color: node.userData.color,
                            blending: THREE.AdditiveBlending,
                            transparent: true,
                            opacity: 0.8
                        });
                        const constellation = new THREE.LineSegments(lineGeometry, lineMaterial);
                        constellationGroup.add(constellation);
                        if (!node.userData.logged) {
                           addLogEntry(node.userData.severity, `Pattern Detected: ${node.userData.type}`);
                           node.userData.logged = true;
                        }
                    }
                });
            }

            positions.needsUpdate = true;
        }

        function populateHistoricalLogs(logs) {
            logContainer.innerHTML = '';
            (logs || []).slice().reverse().forEach(log => {
                if (log.ai_notes) {
                    const date = new Date(log.created_at).toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
                    addLogEntry('INFO', `[${date}] ${log.ai_notes}`);
                }
            });
        }

        function addLogEntry(severity, message) {
            const timestamp = new Date().toLocaleTimeString('en-US', { hour12: false });
            const entry = document.createElement('div');
            entry.className = 'log-entry p-2 rounded-md';
            let severityClass = 'bg-cyan-900/50', severityColor = 'text-cyan-300';
            if (severity === 'WARNING') { severityClass = 'bg-yellow-900/50'; severityColor = 'text-yellow-300'; }
            if (severity === 'CRITICAL') { severityClass = 'bg-red-900/50'; severityColor = 'text-red-300'; }
            entry.classList.add(severityClass);
            entry.innerHTML = `<p class="font-bold ${severityColor}">[${severity}] <span class="font-normal text-gray-400 ml-2">${timestamp}</span></p><p class="text-white">${message}</p>`;
            logContainer.prepend(entry);
            if (logContainer.children.length > 50) logContainer.removeChild(logContainer.lastChild);
        }
        
        function updateSystemStatus(status, color) {
            systemStatusEl.innerText = status;
            systemStatusEl.style.color = color;
            systemStatusEl.className = `font-bold status-${status.toLowerCase()}`;
        }

        window.addEventListener('resize', () => {
            if (camera && renderer) {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }
        }, false);
        
        resyncButton.addEventListener('click', () => {
            if(currentAuthToken) fetchAndInitialize(currentAuthToken);
        });

        function start() {
            try {
                const userToken = sessionStorage.getItem('supabase.auth.token');
                sessionStorage.removeItem('supabase.auth.token');
                if (userToken) {
                    fetchAndInitialize(userToken);
                } else {
                    throw new Error("Active session token not found.");
                }
            } catch (error) {
                console.error("Initialization Error:", error);
                addLogEntry('CRITICAL', 'No active session found. Please access via the button on the main dashboard.');
                updateSystemStatus('OFFLINE', '#6B7280');
            }
        }
        
        start();
    </script>
</body>
</html>